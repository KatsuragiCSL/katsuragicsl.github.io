<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Why use binary search when you can guess where it should be | Script Adults</title>
<meta name="keywords" content="algorithms, wheel-reinvention">
<meta name="description" content="Why ignore 50% of what we know about the data1 Everyone learnt binary search in Algo 101. It is the fastest way (among comparison based searches) to find an element in a sorted array. All you need to carry out the algorithms is the comparison between the target element and the element at the current position. It is widely applicable because it assumes so little from the data. But for many real life problems, we do often know something apart from merely the comparison between the two numbers.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/blogs/computer-science/why-use-binary-search-when-you-can-guess-where-it-should-be/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a9dc64c19dddf7478cc53be6b63c8a1aa436019fca5bfcfd88fa455b97aaba82.css" integrity="sha256-qdxkwZ3d90eMxTvmtjyKGqQ2AZ/KW/z9iPpFW5equoI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blogs/computer-science/why-use-binary-search-when-you-can-guess-where-it-should-be/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>
<script>
    document.addEventListener("tikzjax-load-finished", function(e) {
        const svgEl = e.target;
		let svg = svgEl.outerHTML;

        svg = svg.replaceAll(/("#000"|"black")/g, `"currentColor"`)
				.replaceAll(/("#fff"|"white")/g, `"var(--background-tikz)"`);

		svgEl.outerHTML = svg;
    });
</script>
  

<meta property="og:title" content="Why use binary search when you can guess where it should be" />
<meta property="og:description" content="Why ignore 50% of what we know about the data1 Everyone learnt binary search in Algo 101. It is the fastest way (among comparison based searches) to find an element in a sorted array. All you need to carry out the algorithms is the comparison between the target element and the element at the current position. It is widely applicable because it assumes so little from the data. But for many real life problems, we do often know something apart from merely the comparison between the two numbers." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/blogs/computer-science/why-use-binary-search-when-you-can-guess-where-it-should-be/" />
<meta property="og:image" content="https://images.unsplash.com/photo-1642952469120-eed4b65104be?q=80&amp;w=2070&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" /><meta property="article:section" content="blogs" />
<meta property="article:published_time" content="2024-12-27T23:40:23+08:00" />
<meta property="article:modified_time" content="2024-12-28T00:16:04+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://images.unsplash.com/photo-1642952469120-eed4b65104be?q=80&amp;w=2070&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" />
<meta name="twitter:title" content="Why use binary search when you can guess where it should be"/>
<meta name="twitter:description" content="Why ignore 50% of what we know about the data1 Everyone learnt binary search in Algo 101. It is the fastest way (among comparison based searches) to find an element in a sorted array. All you need to carry out the algorithms is the comparison between the target element and the element at the current position. It is widely applicable because it assumes so little from the data. But for many real life problems, we do often know something apart from merely the comparison between the two numbers."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Why use binary search when you can guess where it should be",
      "item": "http://localhost:1313/blogs/computer-science/why-use-binary-search-when-you-can-guess-where-it-should-be/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Why use binary search when you can guess where it should be",
  "name": "Why use binary search when you can guess where it should be",
  "description": "Why ignore 50% of what we know about the data1 Everyone learnt binary search in Algo 101. It is the fastest way (among comparison based searches) to find an element in a sorted array. All you need to carry out the algorithms is the comparison between the target element and the element at the current position. It is widely applicable because it assumes so little from the data. But for many real life problems, we do often know something apart from merely the comparison between the two numbers.",
  "keywords": [
    "algorithms", "wheel-reinvention"
  ],
  "articleBody": "Why ignore 50% of what we know about the data1 Everyone learnt binary search in Algo 101. It is the fastest way (among comparison based searches) to find an element in a sorted array. All you need to carry out the algorithms is the comparison between the target element and the element at the current position. It is widely applicable because it assumes so little from the data. But for many real life problems, we do often know something apart from merely the comparison between the two numbers. For examples:\nLooking for the phone number of a friend from the contacts Picking an e-book from a folder by its name Sure, nowadays no one uses paper phonebooks anymore and you can instantly get the number you want by the built-in search feature. But you get the idea, let’s pretend that there are no search features for them. And I bet you have been in some cases where you need to look things up in a big repository but cannot use search, like dumpster diving some old and awkward file sharing sites.\nIn the above cases, we do know something about the data: The name (in English, let’s say) of the target and that of the current object I am looking at. Assume I want to look up the phone number of a friend named “Stuart”, then, at the very first step I would not bother to look at the first few entries in my contacts, unless I have a lot of friends whose names start with “S” and none of them are like “Ben”, “Ken”, “Peter”, …, right? I would likely just scroll down to the bottom of my contacts and start there. If I see names like “Tim”, “Teddy” there, I would scroll up JUST A BIT, but not too much, since “Stuart” are supposed to be quite close to these names.\nI guess the above process would be very natural to anyone. Its rationale lies on the information we have for the expected distances between elements: When we know the concrete value of the current element and the distribution of the elements, we can guess the location of our target.\nSo, if about the data we do know more than just their comparisons, why ignore what we know and blindly apply plain binary search? In binary search we don’t have such knowledge, so taking the middle is the “safest” thing to do; but when we have such knowledge, we can be more aggressive.\nOf cause, in real life we usually don’t know what the distribution really is, so we can only guess. Othewise we should be able to hit the target with 1 step, by calculating the exact position of the target. Let’s start with the simplest case: we assume the distribution to be uniform, i.e. for any given array $A$ with length $l$, $A[1] = x$, $A[l] = y$, we assume the values from $x$ to $y$ distribute uniformly within the $l$ elements. So if we want to find $k \\in [x, y]$, we should look at the element at the index $$1 + \\dfrac{(l-1)(k-x)}{y-x}$$ since the values between $x$ and $y$ should be distributed evenly in $A$.\nThe arithmetics $A[l] - A[1]$ above makes sense since we can just assign numbers to the elements once we assume there distribution. For instance assigning $0$ to $a$ and $25$ to $z$ in the case where the data are single lowercase alphabets should do the trick.\nExample: We have $10$ cards, each of them are numbered with an integer within the range from $1$ to $10$ (duplicates possible) on the back side. You can pick one card and turn it over each time. They are sorted. Find $4$.\nObviously we should try the 4th card first. The 4th card is numbered with $2$. Now we can do the same to the 4th to 10th cards. The possible range now is from $2$ to $10$. So we should check the 5th or 6th card. Let pick the 6th. The 6th card is still $2$. Now we can do the same to the 6th to 10th cards. The possible range now is from $2$ to $10$. So we should check the 7th card. The 7th card is $4$. Bingo! Time complexity analysis Warning: the analysis below is very hand-wavy.\nWorst case: Obviously, the worst case is that our guesses are wrong every time. It will takes $O(n)$. For example when we have the possible values from $1$ to $10$ but an array like this: $1, 1, 1, 1, 1, 1, 1, 1, 2, 10$, if we want to find a $2$ in this array, we will have to go through all elements.\nAverage case: (assuming the data is in uniform distribution) Our intuition tells us that it should be faster than binary search, afterall we made use of significant information which binary search doesn’t use to narrow our searches. Should be faster than $\\log n$.\nAnother useful intuition is that our guesses should be “quite close”. Otherwise the distribution would not be “uniform enough”. So how wrong could our guesses be? This question leads us to estimate the expected value of $|K - k_i|$ where $K$ is the index of the target and $k_i$ is our estimated index in the $i^{th}$ round.\nSo our intuition is saying that this expected value should be small, because $K$ “should” be at exactly $k_i$ instead of shifted to somewhere else - we can think of $K$ as a binomial random variable with expected value $k_i$, i.e. $B(k_i, p_i)$ with $p_i = \\dfrac{(l_i)(k_i-x_i)}{y_i-x_i}$. (here $l_i$ is the length the array in the $i^{th}$ round. $x_i$ and $y_i$ are the values in the boundaries.) Hence we have: $$E[(K - k_i)^2] = l_ip_i(1-p_i) \\leq \\dfrac{l_i}{4}$$\nSo the expected value of the square of $|K - k_i|$ is less than $\\dfrac{l_i}{4}$, which means we should expect $|K - k_i| \\leq \\dfrac{\\sqrt{l_i}}{2}$. So roughly speaking our guessed index should drop onto somewhere in $[K - \\dfrac{\\sqrt{l_i}}{2}, K + \\dfrac{\\sqrt{l_i}}{2}]$.\nSo each round we “chop” the array at one of the boundary of $[K - \\dfrac{\\sqrt{l_i}}{2}, K + \\dfrac{\\sqrt{l_i}}{2}]$. We could expect every 2 rounds the array shrinks from being with length $l_i$ to being with length $\\sqrt{l_i}$.\nThat means our problem is broken down to a simlilar problem with size $\\sqrt{l_i}$ and the process should ends when $\\sqrt{l_i} \\leq 2$ i.e. when you only got one choice of index to check in the next step. Some simple calculation tells us that when $i$ reaches $\\log{\\log{l}}$ the said condition will be true.\nSo the average case complexity should be $O(\\log{\\log{l}})$.\n(Note that the reasoning above is very far away from being rigorous, it just helps us to guess the answer. I did not manage to prove it.)\nThe wheel we have reinvented Well, turns out that the algorithm above is just interpolation search, nothing new.\nOf cause since I did not manage to prove the time complexity which is the hardest part, I cannot claim any credits (more accurately, I cannot do so even if I figured out the proof). But I did find a proof by Y Perl2. That proof was complex.\nI just decided that things like this (and the previous blog post about reinventing the Catalan numbers) which rediscover established results by rethinking “101” topics should go into a series called something like “Wheels reinvention”.\nAs a sidenote, if we go the other way around and try to actively reverse engineering the discovery process of something we already knew, that will also be super fun… I should definitely try it.\nMore general cases? Of cause, in real life no one would commit into a not-so-accurate guess and carry through it without a single change: throughout the process of checking the elements in the inferred positions, we gradually learn the actual distribution of the data and hence can adjust our expectation. For example, if you keep getting friends with name start with “L” when you try to find “Mike”, then probably your friend list skewed towards the first half of the alphabets (i.e. you got a lot of friends with names like “Angela”, “Bruce”, but less like “Pam”, “Veronica” etc.), especially those start with “L”. In this case we would like to adjust our assumption so that we put more “weights” to input starts with “L” - so from the current element (let’s say “Luigi”) we will skip more elements to look for “Mike”.\nA typical flow of the process above would be:\nWe assume all names are equally possible to appear in my contacts. The friend I want to look up is “Mike”, it is expected to be in the middle. We check the middle, it is “Luigi”. So next we check the, let’s say $0.1^{th}$ position of the remaining array We got “Luisa”. Well I guess we have a lot of friends with names start with “L”. Maybe next we should check the $0.2^{th}$ position if the uniform distribution says it should be $0.1$ ? (I have to admit that I don’t know much people names start with “L” but after “Luisa”… but whatever) We got “Mila”. We’ve gone to far. If we assume uniform distribution we should check $0.9$. But remember there are a lot of “L” friends, so it should be like $0.95$. and so on… Things go a bit hand wavy at this point. Rigorously defining this generalized algorithm and analyzing it will likely take good effort.\nThis is teasing one of the most famous quotes in the Brazilian JiuJitsu world. https://www.youtube.com/watch?v=qrbnGmdnHOg ↩︎\nYehoshua Perl, Alon Itai, and Haim Avni. 1978. Interpolation search—a log logN search. Commun. ACM 21, 7 (July 1978), 550–553. https://doi.org/10.1145/359545.359557 ↩︎\n",
  "wordCount" : "1610",
  "inLanguage": "en",
  "image":"https://images.unsplash.com/photo-1642952469120-eed4b65104be?q=80\u0026w=2070\u0026auto=format\u0026fit=crop\u0026ixlib=rb-4.0.3\u0026ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D","datePublished": "2024-12-27T23:40:23+08:00",
  "dateModified": "2024-12-28T00:16:04+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blogs/computer-science/why-use-binary-search-when-you-can-guess-where-it-should-be/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Script Adults",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Script Adults (Alt + H)">Script Adults</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blogs/">Blogs</a></div>
    <h1 class="post-title entry-hint-parent">
      Why use binary search when you can guess where it should be
    </h1>
    
    <h3>
      Reinventing interpolation search
    </h3>
    
    <div class="post-meta"><span title='2024-12-27 23:40:23 +0800 CST'>December 27, 2024</span>&nbsp;·&nbsp;<span title='2024-12-28 00:16:04 +0800 CST'>updated December 28, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;<a href="/categories/computer-science"> computer-science</a>

</div>
  </header> 
<figure class="entry-cover"><img loading="eager" src="https://images.unsplash.com/photo-1642952469120-eed4b65104be?q=80&amp;w=2070&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" alt="">
        
</figure><div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#why-ignore-50-of-what-we-know-about-the-data1" aria-label="Why ignore 50% of what we know about the data1">Why ignore 50% of what we know about the data1</a></li>
                <li>
                    <a href="#time-complexity-analysis" aria-label="Time complexity analysis">Time complexity analysis</a></li>
                <li>
                    <a href="#the-wheel-we-have-reinvented" aria-label="The wheel we have reinvented">The wheel we have reinvented</a></li>
                <li>
                    <a href="#more-general-cases" aria-label="More general cases?">More general cases?</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="why-ignore-50-of-what-we-know-about-the-data1">Why ignore 50% of what we know about the data<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup><a hidden class="anchor" aria-hidden="true" href="#why-ignore-50-of-what-we-know-about-the-data1">#</a></h3>
<p>Everyone learnt binary search in Algo 101. It is the fastest way (among comparison based searches) to find an element in a sorted array. All you need to carry out the algorithms is the comparison between the target element and the element at the current position. It is widely applicable because it assumes so little from the data. But for many real life problems, we do often know something apart from merely the comparison between the two numbers. For examples:</p>
<ul>
<li>Looking for the phone number of a friend from the contacts</li>
<li>Picking an e-book from a folder by its name</li>
</ul>
<p>Sure, nowadays no one uses paper phonebooks anymore and you can instantly get the number you want by the built-in search feature. But you get the idea, let&rsquo;s pretend that there are no search features for them. And I bet you have been in some cases where you need to look things up in a big repository but cannot use search, like dumpster diving some old and awkward file sharing sites.</p>
<p>In the above cases, we do know something about the data: The name (in English, let&rsquo;s say) of the target and that of the current object I am looking at.
Assume I want to look up the phone number of a friend named &ldquo;Stuart&rdquo;, then, at the very first step I would not bother to look at the first few entries in my contacts, unless I have a lot of friends whose names start with &ldquo;S&rdquo; and none of them are like &ldquo;Ben&rdquo;, &ldquo;Ken&rdquo;, &ldquo;Peter&rdquo;, &hellip;, right? I would likely just scroll down to the bottom of my contacts and start there. If I see names like &ldquo;Tim&rdquo;, &ldquo;Teddy&rdquo; there, I would scroll up JUST A BIT, but not too much, since &ldquo;Stuart&rdquo; are supposed to be quite close to these names.</p>
<p>I guess the above process would be very natural to anyone. Its rationale lies on the information we have for the <strong>expected distances</strong> between elements: When we know the concrete value of the current element and the distribution of the elements, we can guess the location of our target.</p>
<p>So, if about the data we do know more than just their comparisons, why ignore what we know and blindly apply plain binary search? In binary search we don&rsquo;t have such knowledge, so taking the middle is the &ldquo;safest&rdquo; thing to do; but when we have such knowledge, we can be more aggressive.</p>
<p>Of cause, in real life we usually don&rsquo;t know what the distribution really is, so we can only guess. Othewise we should be able to hit the target with 1 step, by calculating the exact position of the target. Let&rsquo;s start with the simplest case: we assume the distribution to be uniform, i.e. for any given array $A$ with length $l$, $A[1] = x$, $A[l] = y$, we assume the values from $x$ to $y$ distribute uniformly within the $l$ elements. So if we want to find $k \in [x, y]$, we should look at the element at the index $$1 + \dfrac{(l-1)(k-x)}{y-x}$$ since the values between $x$ and $y$ should be distributed evenly in $A$.</p>
<p>The arithmetics $A[l] - A[1]$ above makes sense since we can just assign numbers to the elements once we assume there distribution. For instance assigning $0$ to $a$ and $25$ to $z$ in the case where the data are single lowercase alphabets should do the trick.</p>
<p>Example:
We have $10$ cards, each of them are numbered with an integer within the range from $1$ to $10$ (duplicates possible) on the back side. You can pick one card and turn it over each time. They are sorted. Find $4$.</p>
<ol>
<li>Obviously we should try the 4th card first.</li>
<li>The 4th card is numbered with $2$.</li>
<li>Now we can do the same to the 4th to 10th cards. The possible range now is from $2$ to $10$. So we should check the 5th or 6th card. Let pick the 6th.</li>
<li>The 6th card is still $2$.</li>
<li>Now we can do the same to the 6th to 10th cards. The possible range now is from $2$ to $10$. So we should check the 7th card.</li>
<li>The 7th card is $4$. Bingo!</li>
</ol>
<h3 id="time-complexity-analysis">Time complexity analysis<a hidden class="anchor" aria-hidden="true" href="#time-complexity-analysis">#</a></h3>
<blockquote>
<p><em>Warning: the analysis below is very hand-wavy.</em></p>
</blockquote>
<p><strong>Worst case:</strong> <br>
Obviously, the worst case is that our guesses are wrong every time. It will takes $O(n)$. For example when we have the possible values from $1$ to $10$ but an array like this: $1, 1, 1, 1, 1, 1, 1, 1, 2, 10$, if we want to find a $2$ in this array, we will have to go through all elements.</p>
<p><strong>Average case: (assuming the data is in uniform distribution)</strong> <br>
Our intuition tells us that it should be faster than binary search, afterall we made use of significant information which binary search doesn&rsquo;t use to narrow our searches. Should be faster than $\log n$.</p>
<p>Another useful intuition is that our guesses should be &ldquo;quite close&rdquo;. Otherwise the distribution would not be &ldquo;uniform enough&rdquo;. So how wrong could our guesses be? This question leads us to estimate the expected value of $|K - k_i|$ where $K$ is the index of the target and $k_i$ is our estimated index in the $i^{th}$ round.</p>
<p>So our intuition is saying that this expected value should be small, because $K$ &ldquo;should&rdquo; be at exactly $k_i$ instead of shifted to somewhere else - we can think of $K$ as a binomial random variable with expected value $k_i$, i.e. $B(k_i, p_i)$ with $p_i = \dfrac{(l_i)(k_i-x_i)}{y_i-x_i}$. (here $l_i$ is the length the array in the $i^{th}$ round. $x_i$ and $y_i$ are the values in the boundaries.) Hence we have: $$E[(K - k_i)^2] = l_ip_i(1-p_i) \leq \dfrac{l_i}{4}$$</p>
<p>So the expected value of the square of $|K - k_i|$ is less than $\dfrac{l_i}{4}$, which means we should expect $|K - k_i| \leq \dfrac{\sqrt{l_i}}{2}$. So roughly speaking our guessed index should drop onto somewhere in $[K - \dfrac{\sqrt{l_i}}{2}, K + \dfrac{\sqrt{l_i}}{2}]$.</p>
<p><img loading="lazy" src="/Why-use-binary-search-when-you-can-guess-where-it-should-be/i-th-interval.png" alt=""  />
</p>
<p>So each round we &ldquo;chop&rdquo; the array at one of the boundary of $[K - \dfrac{\sqrt{l_i}}{2}, K + \dfrac{\sqrt{l_i}}{2}]$. We could expect every 2 rounds the array shrinks from being with length $l_i$ to being with length $\sqrt{l_i}$.</p>
<p><img loading="lazy" src="/Why-use-binary-search-when-you-can-guess-where-it-should-be/process.png" alt=""  />
</p>
<p>That means our problem is broken down to a simlilar problem with size $\sqrt{l_i}$ and the process should ends when $\sqrt{l_i} \leq 2$ i.e. when you only got one choice of index to check in the next step. Some simple calculation tells us that when $i$ reaches $\log{\log{l}}$ the said condition will be true.</p>
<p>So the average case complexity should be $O(\log{\log{l}})$.</p>
<p><em>(Note that the reasoning above is very far away from being rigorous, it just helps us to guess the answer. I did not manage to prove it.)</em></p>
<h3 id="the-wheel-we-have-reinvented">The wheel we have reinvented<a hidden class="anchor" aria-hidden="true" href="#the-wheel-we-have-reinvented">#</a></h3>
<p>Well, turns out that the algorithm above is just <a href="https://en.wikipedia.org/wiki/Interpolation_search">interpolation search</a>, nothing new.</p>
<p>Of cause since I did not manage to prove the time complexity which is the hardest part, I cannot claim any credits (more accurately, I cannot do so even if I figured out the proof). But I did find a proof by <strong>Y Perl</strong><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. That proof was complex.</p>
<p>I just decided that things like this (and the previous blog post about <a href="https://katsuragicsl.github.io/blogs/mathematics/reinventing-catalan-numbers/">reinventing the Catalan numbers</a>) which rediscover established results by rethinking &ldquo;101&rdquo; topics should go into a series called something like &ldquo;Wheels reinvention&rdquo;.</p>
<p>As a sidenote, if we go the other way around and try to actively reverse engineering the discovery process of something we already knew, that will also be super fun&hellip; I should definitely try it.</p>
<h3 id="more-general-cases">More general cases?<a hidden class="anchor" aria-hidden="true" href="#more-general-cases">#</a></h3>
<p>Of cause, in real life no one would commit into a not-so-accurate guess and carry through it without a single change: throughout the process of checking the elements in the inferred positions, we gradually learn the actual distribution of the data and hence can adjust our expectation. For example, if you keep getting friends with name start with &ldquo;L&rdquo; when you try to find &ldquo;Mike&rdquo;, then probably your friend list skewed towards the first half of the alphabets (i.e. you got a lot of friends with names like &ldquo;Angela&rdquo;, &ldquo;Bruce&rdquo;, but less like &ldquo;Pam&rdquo;, &ldquo;Veronica&rdquo; etc.), especially those start with &ldquo;L&rdquo;. In this case we would like to adjust our assumption so that we put more &ldquo;weights&rdquo; to input starts with &ldquo;L&rdquo; - so from the current element (let&rsquo;s say &ldquo;Luigi&rdquo;) we will skip more elements to look for &ldquo;Mike&rdquo;.</p>
<p>A typical flow of the process above would be:</p>
<p><img loading="lazy" src="/Why-use-binary-search-when-you-can-guess-where-it-should-be/process-generalized.png" alt=""  />
</p>
<ol>
<li>We assume all names are equally possible to appear in my contacts. The friend I want to look up is &ldquo;Mike&rdquo;, it is expected to be in the middle.</li>
<li>We check the middle, it is &ldquo;Luigi&rdquo;. So next we check the, let&rsquo;s say $0.1^{th}$ position of the remaining array</li>
<li>We got &ldquo;Luisa&rdquo;.</li>
<li>Well I guess we have a lot of friends with names start with &ldquo;L&rdquo;. Maybe next we should check the $0.2^{th}$ position if the uniform distribution says it should be $0.1$ ? (I have to admit that I don&rsquo;t know much people names start with &ldquo;L&rdquo; but after &ldquo;Luisa&rdquo;&hellip; but whatever)</li>
<li>We got &ldquo;Mila&rdquo;.</li>
<li>We&rsquo;ve gone to far. If we assume uniform distribution we should check $0.9$. But remember there are a lot of &ldquo;L&rdquo; friends, so it should be like $0.95$.</li>
<li>and so on&hellip;</li>
</ol>
<p>Things go a bit hand wavy at this point. Rigorously defining this generalized algorithm and analyzing it will likely take good effort.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>This is teasing one of the most famous quotes in the Brazilian JiuJitsu world. <a href="https://www.youtube.com/watch?v=qrbnGmdnHOg">https://www.youtube.com/watch?v=qrbnGmdnHOg</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Yehoshua Perl, Alon Itai, and Haim Avni. 1978. Interpolation search—a log logN search. Commun. ACM 21, 7 (July 1978), 550–553. <a href="https://doi.org/10.1145/359545.359557">https://doi.org/10.1145/359545.359557</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


  </div>
  

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/algorithms/">Algorithms</a></li>
      <li><a href="http://localhost:1313/tags/wheel-reinvention/">Wheel-Reinvention</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blogs/thoughts/our-legal-and-moral-system-flavors-jerks/">
    <span class="title">« Prev</span>
    <br>
    <span>Our legal (and moral) system flavors the jerks</span>
  </a>
  <a class="next" href="http://localhost:1313/blogs/thoughts/level-of-abstraction/">
    <span class="title">Next »</span>
    <br>
    <span>Work at the level of abstraction that works for you</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why use binary search when you can guess where it should be on x"
            href="https://x.com/intent/tweet/?text=Why%20use%20binary%20search%20when%20you%20can%20guess%20where%20it%20should%20be&amp;url=http%3a%2f%2flocalhost%3a1313%2fblogs%2fcomputer-science%2fwhy-use-binary-search-when-you-can-guess-where-it-should-be%2f&amp;hashtags=algorithms%2cwheel-reinvention">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why use binary search when you can guess where it should be on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fblogs%2fcomputer-science%2fwhy-use-binary-search-when-you-can-guess-where-it-should-be%2f&amp;title=Why%20use%20binary%20search%20when%20you%20can%20guess%20where%20it%20should%20be&amp;summary=Why%20use%20binary%20search%20when%20you%20can%20guess%20where%20it%20should%20be&amp;source=http%3a%2f%2flocalhost%3a1313%2fblogs%2fcomputer-science%2fwhy-use-binary-search-when-you-can-guess-where-it-should-be%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why use binary search when you can guess where it should be on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblogs%2fcomputer-science%2fwhy-use-binary-search-when-you-can-guess-where-it-should-be%2f&title=Why%20use%20binary%20search%20when%20you%20can%20guess%20where%20it%20should%20be">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why use binary search when you can guess where it should be on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fblogs%2fcomputer-science%2fwhy-use-binary-search-when-you-can-guess-where-it-should-be%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why use binary search when you can guess where it should be on whatsapp"
            href="https://api.whatsapp.com/send?text=Why%20use%20binary%20search%20when%20you%20can%20guess%20where%20it%20should%20be%20-%20http%3a%2f%2flocalhost%3a1313%2fblogs%2fcomputer-science%2fwhy-use-binary-search-when-you-can-guess-where-it-should-be%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why use binary search when you can guess where it should be on telegram"
            href="https://telegram.me/share/url?text=Why%20use%20binary%20search%20when%20you%20can%20guess%20where%20it%20should%20be&amp;url=http%3a%2f%2flocalhost%3a1313%2fblogs%2fcomputer-science%2fwhy-use-binary-search-when-you-can-guess-where-it-should-be%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why use binary search when you can guess where it should be on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Why%20use%20binary%20search%20when%20you%20can%20guess%20where%20it%20should%20be&u=http%3a%2f%2flocalhost%3a1313%2fblogs%2fcomputer-science%2fwhy-use-binary-search-when-you-can-guess-where-it-should-be%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

    <script src="https://utteranc.es/client.js"
            label="comment"
            repo="KatsuragiCSL/katsuragicsl.github.io"
            issue-term="title"
            theme="preferred-color-scheme"
            crossorigin="anonymous"
            async>
    </script>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Script Adults</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
