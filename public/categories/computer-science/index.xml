<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Computer-Science on Script Adults</title>
    <link>http://localhost:1313/categories/computer-science/</link>
    <description>Recent content in Computer-Science on Script Adults</description>
    <image>
      <title>Script Adults</title>
      <url>http://localhost:1313/images/papermod-cover.png</url>
      <link>http://localhost:1313/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.128.2</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 28 Dec 2024 00:16:04 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/computer-science/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Why use binary search when you can guess where it should be</title>
      <link>http://localhost:1313/blogs/computer-science/why-use-binary-search-when-you-can-guess-where-it-should-be/</link>
      <pubDate>Fri, 27 Dec 2024 23:40:23 +0800</pubDate>
      <guid>http://localhost:1313/blogs/computer-science/why-use-binary-search-when-you-can-guess-where-it-should-be/</guid>
      <description>Why ignore 50% of what we know about the data1 Everyone learnt binary search in Algo 101. It is the fastest way (among comparison based searches) to find an element in a sorted array. All you need to carry out the algorithms is the comparison between the target element and the element at the current position. It is widely applicable because it assumes so little from the data. But for many real life problems, we do often know something apart from merely the comparison between the two numbers.</description>
    </item>
    <item>
      <title>From casual description of Turing Machine to the density of uncomputable functions</title>
      <link>http://localhost:1313/blogs/computer-science/from-casual-description-of-turing-machine-to-uncompuatble-functions/</link>
      <pubDate>Fri, 09 Aug 2024 01:23:55 +0800</pubDate>
      <guid>http://localhost:1313/blogs/computer-science/from-casual-description-of-turing-machine-to-uncompuatble-functions/</guid>
      <description>Defining the machine by describing it In Sipser&amp;rsquo;s Introduction to the theory of computation, a alternative way of defining a Turing machine (other than defining the formal 7-tuple, which is a PITA) - by its &amp;ldquo;description&amp;rdquo;. Example (from the proof of $A_{TM}$ is deciable):
M = â€œOn input &amp;lt;B, w&amp;gt;, where B is a DFA and w is a string: 1. Simulate B on input w. 2. If the simulation ends in an accept state, accept .</description>
    </item>
  </channel>
</rss>
