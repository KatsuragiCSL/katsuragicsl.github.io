[{"content":"After the huge attention gained by deepseek R1, I have seen a good amount of people immediately went to looking for censorships (which are expected to exist), laughed at it, and looked down on it. They totally missed the points and these behaviors made them look like slaves of their very own defense mechanism1.\nDeepseek did make some techonological breakthroughs. Indeed the censorship is a defect of such a great product. However making jokes on it with its censorships is just like catching grammatical errors in an insightful article and disdain the article because of that. Yes, grammatical errors are errors, catching itself could be useful, but doing that for attacking an insightsul article is another thing. It just misses the point.\nIf you see China as a rival, it is also like laughing at your enemy\u0026rsquo;s weapons just because they \u0026ldquo;look\u0026rdquo; funny.\nIf you want to disdain an insightful article, disdain by its ideas.\nThe accuses about cheating with OpenAI data are even more related and look less like jokes. (if ignore the validity of those accuses)\nAn even more related critiques can be pointing out the fact that it did not push the limit of AI reasoning ability (since it is roughly as good as o1), although it optimized the whole process. Of cause making training cheaper is important and it helps researchers to push the limits of AI as well (since the testing cost became lower as well). Depends on your interested areas, you could value Deepseek differently. \u0026lt;- This, is still way better than taunting it because of the censorships.\nSince they could not bare the fact that Chinese make breakthroughs that others did not make. This is called \u0026ldquo;glass-made heart\u0026rdquo; in Chinese, ironically mostly used in describing the hysterical behaviors of pro-CCP people when they heard something that is unfavorable to CCP.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://katsuragicsl.github.io/blogs/thoughts/picking-grammatical-mistakes-in-an-insightful-article/","summary":"After the huge attention gained by deepseek R1, I have seen a good amount of people immediately went to looking for censorships (which are expected to exist), laughed at it, and looked down on it. They totally missed the points and these behaviors made them look like slaves of their very own defense mechanism1.\nDeepseek did make some techonological breakthroughs. Indeed the censorship is a defect of such a great product.","title":"Picking grammatical mistakes in an insightful article"},{"content":"Just added support for tikzjax since I received some feedback about my hand-drawn diagrams are hard to read\u0026hellip;now I can use nice graphs like these:\nsource: https://tikzjax.com/ source: https://tikzjax.com/ source: https://tikz.net/ source: https://tikz.net/ ","permalink":"https://katsuragicsl.github.io/blogs/meta/added-tikzjax-support/","summary":"Just added support for tikzjax since I received some feedback about my hand-drawn diagrams are hard to read\u0026hellip;now I can use nice graphs like these:\nsource: https://tikzjax.com/ source: https://tikzjax.com/ source: https://tikz.net/ source: https://tikz.net/ ","title":"Added tikzjax support"},{"content":" Disclaimer: The author\u0026rsquo;s knowledge about the legal system by no means applies to anywhere outside of his homeland. But what is legal or illegal should be similar enough for the discussion below - at least for first world countries, I guess.\nThat said, the author is not a lawyer and does not have accurate knowledge of any concrete laws. But one does not need to know (too many of) them for this article.\nThose jerks we see everyday Jerks are not criminals. Maybe they do break some laws in some occasions, but the \u0026ldquo;crimes\u0026rdquo; are not serious.\nJerks are those who commit offences to people near them. They do things that are barely legal but extremely annoying and even morally wrong. They know what they are doing, and they refuse to change, they got the brass neck to do awful things.\nThey are those who talk or play music really loud on a busy train, or those who occupy unnecessary space or standing unnecssarily close to annoy people, those who say roundabout and mean things (but right in your face), or those take a little advantages of you and act like he is right.\nThey are annoying not because they give you offences, they do give you offences, but the annoying part is that you don\u0026rsquo;t have a good option to make them pay without hurting yourself.\nYou options look like this:\nThe red (same as the color of the word \u0026ldquo;the jerk\u0026rdquo;) numbers in the boxes represent the gain/ loss, or how happy will the jerk be in different cases. The blue numbers are the counterparts for you. Since what the jerks do are not something seriously hurting your benifit, if you suck it, you will get let\u0026rsquo;s say $-5$. If you fight back, for examples by condemning them verbally or by any form or force (moving them out of what they should not be at; stopping whatever physical actions they are doing; or even giving them a big slap), it does offend them back, but it is also highly likely going to cost you more. Let\u0026rsquo;s say it costs you $-10$. (Note that this analysis works only for good citizens, normal people who have to go to work tomorrow so that they can feed themselves and their family. Otherwise you might be more willing to take the consequences of escalating the scene and hence more willing to fight back. We will discuss only in the case of that we are normal people.)\nSome people might think there should be some ways to fight back without too much cost. I will list a few of them that I could imagine, and explain why they are bad ideas. Honestly, if you are neither a bad person nor a saint nor are pampered, you will agree with me.\nCondemn them. Most of the jerks are thick-skinned. You only irritate yourself. Film a video of what they did and put it on Youtube or some Facebook groups They do get some attention and shitstorms among a small group of people, but soon they will be forgotten. Do you remember the face of the person you see the last such video? I don\u0026rsquo;t. I bet you neither. Maybe those who know them will recognize them and remember their behaviors much longer. But if they are kind and loyal enough to those who are close to them, or more accurately, those who really matter to them, they will likely be forgiven by those people. And they will still have a good life.\nSome people believe that those who do jerky behaviors to them must be jerky to everyone, and hence they will get freezed out. But that is not true. They can be a great spouse, a great parent, a great son/ daughter. \u0026ldquo;Clever\u0026rdquo; jerks know who to bully and who not to. See the next section for more. Another problem is that there are some jerky behaviors that you wouldn\u0026rsquo;t have the time to film a video or take a picture. Such as bumping people on the street for no reasons and walking away extremely fast. (Sidenote: if you are a big guy you can do this for \u0026ldquo;good purposes\u0026rdquo; sometimes. But it only works in very few occasions and does not work at all for someone not physically strong.) Call the police. Meh. Most jerky behaviors are barely legal as we said. Cops are either unable to or not willing to do much. So, the \u0026ldquo;best\u0026rdquo; option here is to suck it, just like what most people do. What is so bad is that, the \u0026ldquo;best option\u0026rdquo; is always letting the good people \u0026ldquo;lose\u0026rdquo; and the jerks \u0026ldquo;win\u0026rdquo;. The rationally best choice gives the shittiest outcomes.\nUnderstand that facing criminals is a differnt story. If someone is commiting crimes against you, you won\u0026rsquo;t be bothered by the same problem. You can legally fight back. And if the crime is serious enough, you won\u0026rsquo;t hesitate to pay the cost of time, effort and money to fight back by any means, if you are able to do so. Of cause most of the time you don\u0026rsquo;t even have the ability to fight back immediately in the case of serious crimes, but that is another issue. For example, when someone is commiting physical assault on you, assuming you are 50/ 50 with him in a fight, then you options will look like this:\nA totally different situation.\nMorals does not work for strangers Certainly the legal system is not the only reward and punishment system in our society. Morals is a strong force to restrict people\u0026rsquo;s behavior\nMoral system works well for a group of people who know each other and will live with, or work with, or rely on, for a significant period of time, like colleagues, families, close neighbourhood especially in rural areas. If you act unethically and get freezed out by those people, you will have a really hard time. Especially in rural areas, that would makes the whole village unlivable for you.\nHowever, morals does not work for strangers. If someone is almost sure that he/ she will see you only once in a lifetime, he/ she can literally do anything to you without consequences (except the legal consequences). There is nothing we can do about it. You can condemn those who are not kind-hearted and curse them with the ugliest words you know, nothing would happen in reality, except that you are damaged and angry.\nThis is just like the difference between normal prisoners\u0026rsquo; dilemma and prisoners\u0026rsquo; dilemma with infinite or unknown number of rounds. If there is only one round (you only see each other once in a life time), the \u0026ldquo;best\u0026rdquo; strategy is to betray. Only when you don\u0026rsquo;t know when will the relationship with someone end, there is possibility to cooperate.\nIt sounds horrible to those innocent, but that is how it works.\nThe worse thing is that, morals of societies that are more\u0026hellip;uh, barbaric, actually flavors jerks less (Of cause barbaric societies have other problems). Jerks enjoy more advantages in civilization.\nMorals from so-called civilized world makes it worse I forgot where did I see a sarcastic line about respects, not the exact wordings but more or less the same meaning:\nCavemen know repects better than us. Cuz if you don\u0026rsquo;t respect someone you will be still be fine. But if a caveman doesn\u0026rsquo;t repect another caveman, his head will probably be cut in half.\nThis is a bit exaggerated, but it does not hurt the fact modern world overly vilifies and oppresses violence.\nWhat if minor violence against jerky behaviors is widely acceptable and is free from moral condemnation? Perhaps let\u0026rsquo;s get a bit extreme to show the effect: if such thing is even encouraged in our moral system, so most people are tend to fight back to make the jerks pay, now the jerks need to consider between acting like a jerk or not to do so.\nIn this case, not acting like a jerk will be more attractive.\nA sidenote is that, undoubtedly violence out of control creates other problems. The solution proposed by civilization is that we all should agree to \u0026ldquo;outsource\u0026rdquo; our rightful violence usages to the law enforcement, so that the violence is easier to manage in theory, and cough HOPEFULLY cough we can ensure that the law enforcement use force the right way.\nThe bottomline is, moral system can\u0026rsquo;t save you from jerks. It even flavors them.\nIt is an unfair game I hope I have demonstrated that how our laws and moral beliefs put them in such a situation that doing jerky things to strangers are flavored. It puts us into an unfair game - they have the option to give you (minor) offences with almost zero cost, but your other options always cost you more than that, and they are always winning.\nThe very reason we hate jerks is not how bad they are, but that they are just bad enough to irritate and causes minor damages, but \u0026ldquo;harmless\u0026rdquo; enough to get away from consequences so often. It is always the unfairness.\nRationality As a single person, there is not much you can do. If you are a \u0026ldquo;rational\u0026rdquo; (which means you always pick the choices that bring you the most benifits) person, your \u0026ldquo;best\u0026rdquo; choice is still to suck it. Things will only change in either case:\nThe legal and moral systems change so that they do not flavor jerks anymore. You give up to be a \u0026ldquo;rational\u0026rdquo; person. In fact if everyone is \u0026ldquo;rational\u0026rdquo; the legal and moral systems change will not change. It is always some \u0026ldquo;insane\u0026rdquo; people who act against their own interest and change the tide. Of cause it does not mean that you can go on the street to slap a jerk and the whole world will change overnight and you don\u0026rsquo;t have to be arrested. No one know when will a change comes or will it even come.\nAs a sidenote, studying how \u0026ldquo;irrational\u0026rdquo; choices can bring good result is also an interesting topic.\n","permalink":"https://katsuragicsl.github.io/blogs/thoughts/our-legal-and-moral-system-flavors-jerks/","summary":"Disclaimer: The author\u0026rsquo;s knowledge about the legal system by no means applies to anywhere outside of his homeland. But what is legal or illegal should be similar enough for the discussion below - at least for first world countries, I guess.\nThat said, the author is not a lawyer and does not have accurate knowledge of any concrete laws. But one does not need to know (too many of) them for this article.","title":"Our legal (and moral) system flavors the jerks"},{"content":"Why ignore 50% of what we know about the data1 Everyone learnt binary search in Algo 101. It is the fastest way (among comparison based searches) to find an element in a sorted array. All you need to carry out the algorithms is the comparison between the target element and the element at the current position. It is widely applicable because it assumes so little from the data. But for many real life problems, we do often know something apart from merely the comparison between the two numbers. For examples:\nLooking for the phone number of a friend from the contacts Picking an e-book from a folder by its name Sure, nowadays no one uses paper phonebooks anymore and you can instantly get the number you want by the built-in search feature. But you get the idea, let\u0026rsquo;s pretend that there are no search features for them. And I bet you have been in some cases where you need to look things up in a big repository but cannot use search, like dumpster diving some old and awkward file sharing sites.\nIn the above cases, we do know something about the data: The name (in English, let\u0026rsquo;s say) of the target and that of the current object I am looking at. Assume I want to look up the phone number of a friend named \u0026ldquo;Stuart\u0026rdquo;, then, at the very first step I would not bother to look at the first few entries in my contacts, unless I have a lot of friends whose names start with \u0026ldquo;S\u0026rdquo; and none of them are like \u0026ldquo;Ben\u0026rdquo;, \u0026ldquo;Ken\u0026rdquo;, \u0026ldquo;Peter\u0026rdquo;, \u0026hellip;, right? I would likely just scroll down to the bottom of my contacts and start there. If I see names like \u0026ldquo;Tim\u0026rdquo;, \u0026ldquo;Teddy\u0026rdquo; there, I would scroll up JUST A BIT, but not too much, since \u0026ldquo;Stuart\u0026rdquo; are supposed to be quite close to these names.\nI guess the above process would be very natural to anyone. Its rationale lies on the information we have for the expected distances between elements: When we know the concrete value of the current element and the distribution of the elements, we can guess the location of our target.\nSo, if about the data we do know more than just their comparisons, why ignore what we know and blindly apply plain binary search? In binary search we don\u0026rsquo;t have such knowledge, so taking the middle is the \u0026ldquo;safest\u0026rdquo; thing to do; but when we have such knowledge, we can be more aggressive.\nOf cause, in real life we usually don\u0026rsquo;t know what the distribution really is, so we can only guess. Othewise we should be able to hit the target with 1 step, by calculating the exact position of the target. Let\u0026rsquo;s start with the simplest case: we assume the distribution to be uniform, i.e. for any given array $A$ with length $l$, $A[1] = x$, $A[l] = y$, we assume the values from $x$ to $y$ distribute uniformly within the $l$ elements. So if we want to find $k \\in [x, y]$, we should look at the element at the index $$1 + \\dfrac{(l-1)(k-x)}{y-x}$$ since the values between $x$ and $y$ should be distributed evenly in $A$.\nThe arithmetics $A[l] - A[1]$ above makes sense since we can just assign numbers to the elements once we assume there distribution. For instance assigning $0$ to $a$ and $25$ to $z$ in the case where the data are single lowercase alphabets should do the trick.\nExample: We have $10$ cards, each of them are numbered with an integer within the range from $1$ to $10$ (duplicates possible) on the back side. You can pick one card and turn it over each time. They are sorted. Find $4$.\nObviously we should try the 4th card first. The 4th card is numbered with $2$. Now we can do the same to the 4th to 10th cards. The possible range now is from $2$ to $10$. So we should check the 5th or 6th card. Let pick the 6th. The 6th card is still $2$. Now we can do the same to the 6th to 10th cards. The possible range now is from $2$ to $10$. So we should check the 7th card. The 7th card is $4$. Bingo! Time complexity analysis Warning: the analysis below is very hand-wavy.\nWorst case: Obviously, the worst case is that our guesses are wrong every time. It will takes $O(n)$. For example when we have the possible values from $1$ to $10$ but an array like this: $1, 1, 1, 1, 1, 1, 1, 1, 2, 10$, if we want to find a $2$ in this array, we will have to go through all elements.\nAverage case: (assuming the data is in uniform distribution) Our intuition tells us that it should be faster than binary search, afterall we made use of significant information which binary search doesn\u0026rsquo;t use to narrow our searches. Should be faster than $\\log n$.\nAnother useful intuition is that our guesses should be \u0026ldquo;quite close\u0026rdquo;. Otherwise the distribution would not be \u0026ldquo;uniform enough\u0026rdquo;. So how wrong could our guesses be? This question leads us to estimate the expected value of $|K - k_i|$ where $K$ is the index of the target and $k_i$ is our estimated index in the $i^{th}$ round.\nSo our intuition is saying that this expected value should be small, because $K$ \u0026ldquo;should\u0026rdquo; be at exactly $k_i$ instead of shifted to somewhere else - we can think of $K$ as a binomial random variable with expected value $k_i$, i.e. $B(k_i, p_i)$ with $p_i = \\dfrac{(l_i)(k_i-x_i)}{y_i-x_i}$. (here $l_i$ is the length the array in the $i^{th}$ round. $x_i$ and $y_i$ are the values in the boundaries.) Hence we have: $$E[(K - k_i)^2] = l_ip_i(1-p_i) \\leq \\dfrac{l_i}{4}$$\nSo the expected value of the square of $|K - k_i|$ is less than $\\dfrac{l_i}{4}$, which means we should expect $|K - k_i| \\leq \\dfrac{\\sqrt{l_i}}{2}$. So roughly speaking our guessed index should drop onto somewhere in $[K - \\dfrac{\\sqrt{l_i}}{2}, K + \\dfrac{\\sqrt{l_i}}{2}]$.\nSo each round we \u0026ldquo;chop\u0026rdquo; the array at one of the boundary of $[K - \\dfrac{\\sqrt{l_i}}{2}, K + \\dfrac{\\sqrt{l_i}}{2}]$. We could expect every 2 rounds the array shrinks from being with length $l_i$ to being with length $\\sqrt{l_i}$.\nThat means our problem is broken down to a simlilar problem with size $\\sqrt{l_i}$ and the process should ends when $\\sqrt{l_i} \\leq 2$ i.e. when you only got one choice of index to check in the next step. Some simple calculation tells us that when $i$ reaches $\\log{\\log{l}}$ the said condition will be true.\nSo the average case complexity should be $O(\\log{\\log{l}})$.\n(Note that the reasoning above is very far away from being rigorous, it just helps us to guess the answer. I did not manage to prove it.)\nThe wheel we have reinvented Well, turns out that the algorithm above is just interpolation search, nothing new.\nOf cause since I did not manage to prove the time complexity which is the hardest part, I cannot claim any credits (more accurately, I cannot do so even if I figured out the proof). But I did find a proof by Y Perl2. That proof was complex.\nI just decided that things like this (and the previous blog post about reinventing the Catalan numbers) which rediscover established results by rethinking \u0026ldquo;101\u0026rdquo; topics should go into a series called something like \u0026ldquo;Wheels reinvention\u0026rdquo;.\nAs a sidenote, if we go the other way around and try to actively reverse engineering the discovery process of something we already knew, that will also be super fun\u0026hellip; I should definitely try it.\nMore general cases? Of cause, in real life no one would commit into a not-so-accurate guess and carry through it without a single change: throughout the process of checking the elements in the inferred positions, we gradually learn the actual distribution of the data and hence can adjust our expectation. For example, if you keep getting friends with name start with \u0026ldquo;L\u0026rdquo; when you try to find \u0026ldquo;Mike\u0026rdquo;, then probably your friend list skewed towards the first half of the alphabets (i.e. you got a lot of friends with names like \u0026ldquo;Angela\u0026rdquo;, \u0026ldquo;Bruce\u0026rdquo;, but less like \u0026ldquo;Pam\u0026rdquo;, \u0026ldquo;Veronica\u0026rdquo; etc.), especially those start with \u0026ldquo;L\u0026rdquo;. In this case we would like to adjust our assumption so that we put more \u0026ldquo;weights\u0026rdquo; to input starts with \u0026ldquo;L\u0026rdquo; - so from the current element (let\u0026rsquo;s say \u0026ldquo;Luigi\u0026rdquo;) we will skip more elements to look for \u0026ldquo;Mike\u0026rdquo;.\nA typical flow of the process above would be:\nWe assume all names are equally possible to appear in my contacts. The friend I want to look up is \u0026ldquo;Mike\u0026rdquo;, it is expected to be in the middle. We check the middle, it is \u0026ldquo;Luigi\u0026rdquo;. So next we check the, let\u0026rsquo;s say $0.1^{th}$ position of the remaining array We got \u0026ldquo;Luisa\u0026rdquo;. Well I guess we have a lot of friends with names start with \u0026ldquo;L\u0026rdquo;. Maybe next we should check the $0.2^{th}$ position if the uniform distribution says it should be $0.1$ ? (I have to admit that I don\u0026rsquo;t know much people names start with \u0026ldquo;L\u0026rdquo; but after \u0026ldquo;Luisa\u0026rdquo;\u0026hellip; but whatever) We got \u0026ldquo;Mila\u0026rdquo;. We\u0026rsquo;ve gone to far. If we assume uniform distribution we should check $0.9$. But remember there are a lot of \u0026ldquo;L\u0026rdquo; friends, so it should be like $0.95$. and so on\u0026hellip; Things go a bit hand wavy at this point. Rigorously defining this generalized algorithm and analyzing it will likely take good effort.\nThis is teasing one of the most famous quotes in the Brazilian JiuJitsu world. https://www.youtube.com/watch?v=qrbnGmdnHOg\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nYehoshua Perl, Alon Itai, and Haim Avni. 1978. Interpolation search—a log logN search. Commun. ACM 21, 7 (July 1978), 550–553. https://doi.org/10.1145/359545.359557\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://katsuragicsl.github.io/blogs/computer-science/why-use-binary-search-when-you-can-guess-where-it-should-be/","summary":"Why ignore 50% of what we know about the data1 Everyone learnt binary search in Algo 101. It is the fastest way (among comparison based searches) to find an element in a sorted array. All you need to carry out the algorithms is the comparison between the target element and the element at the current position. It is widely applicable because it assumes so little from the data. But for many real life problems, we do often know something apart from merely the comparison between the two numbers.","title":"Why use binary search when you can guess where it should be"},{"content":"Ladder of abstraction Well the title is obviously a tweak of the \u0026ldquo;ladder of abstraction\u0026rdquo;. For those who does not know, \u0026ldquo;ladder of abstraction\u0026rdquo; refers to the classic essay by Bret Victor. I am kind of stealing this terminilogy for the reader to visualize climbing up and down on the ladder of abstraction to make it easier to explain the nature of different jobs. The main question this blog post deals with is:\nWhy do some people love doing X but hate to do X as a job, complaining about having to catch up with trends/ news? And my answer is those people are working at the \u0026ldquo;wrong\u0026rdquo; level of abstraction of their fields.\n\u0026ldquo;I love tech\u0026hellip;but I hate my tech career\u0026rdquo; As a person working in security, I used to be confused when I hear people complaining how much they have to keep themselves updated and learn the latest tech stacks, the typical quotes of them are:\nI spent X years to learning programming language/ framework A, and now I have to learn a new language/ framework B or I will be replaced by those young devs. I hate this.\nIt is exhausting to work in security as you have to keep up with the latest news such as XYZ company is hacked\u0026hellip;\n(it might be unbelievable for you the reader, since if you are reading this obviously you are very different from the crowd, but trust me, there are a bunch of such people).\nAre they not curious people? Do they not enjoy the technical things they are working on? I used to think so, I thought it is just about personalities, but I was wrong. They ARE curious people and they do enjoy the things they work on, what they complain about is actually the level of details they have to handle.\nThe guy who complains about having to learn new programming language, he does enjoy programming (well, at least does not hate it), what he hates was the requirements of actually implementing a software while keeping up with the trends. I would boldly say that he should do competitive programming instead of developing CMS systems for his clients. To work as a developer and implement CMS systems is working at a very \u0026ldquo;low level\u0026rdquo; of the abstraction ladder - you have to take care of virtually every bits of the software you create, including which languages/ frameworks to use, due to technical or non-technical reasons (Maybe a new language/ framework does give better performance, maybe the market just want to see something that is \u0026ldquo;up to date\u0026rdquo; and flashy).\nThe lower you are working at the abstraction ladder, the faster the world around you changes, and you have to keep up to that. However to do competitive programming, no one cares which language do you use, all you do is almost just to think about how to manipulate the data, if there exists a machine that can run your pseudo codes, you can write pseudo code too - the language/ framework selection factor is abtracted from your task.\nFor those who complain about having to \u0026ldquo;keep up with the latest news\u0026rdquo; (probably working in SOC or similar), similar argument applies, perhaps they should be a researcher of malware techniques.\nOf cause, can doing competitive programming or researching malware techniques make a living for them is another story ツ, but the goal of this blog post is to reveal the true reasons of why are some people in kinda love/ hate relation with their professions and the \u0026ldquo;level of abstraction\u0026rdquo; embedded in the nature of many jobs.\nDon\u0026rsquo;t get me wrong - I am not suggesting that some work are superior than others, but different people do their best in different types of work, and if someone constantly complaint about his/ her job nature especially about the amount of details, perhaps they are working in the wrong level of abstraction, and they should be aware of their true feeling about the work. Perhaps they should look for a position that allows them to work at higher level of abstraction.\nAnd don\u0026rsquo;t forget that some people do really love to be drown in details by working at very low levels.\n","permalink":"https://katsuragicsl.github.io/blogs/thoughts/level-of-abstraction/","summary":"Ladder of abstraction Well the title is obviously a tweak of the \u0026ldquo;ladder of abstraction\u0026rdquo;. For those who does not know, \u0026ldquo;ladder of abstraction\u0026rdquo; refers to the classic essay by Bret Victor. I am kind of stealing this terminilogy for the reader to visualize climbing up and down on the ladder of abstraction to make it easier to explain the nature of different jobs. The main question this blog post deals with is:","title":"Work at the level of abstraction that works for you"},{"content":"Relaxation as a result of mastery, instead of a prerequisites In many sports/ crafts that I have experienced, relaxation is considered by many the prerequisites of mastery:\nIn playing piano, your fingers, wrists, arms and shoulders have to be relax or you will find it extremely hard to press the right keys fluently; In online games that require fast reactions, rookies hands are stiff and they press buttons with unnecessary strength and range of motion, which stops them from pressing right buttons at the right time smoothly; In jiujitsu, being reasonably relax helps you to perform efficient moves, saving your energy and gives you more choices in different situations in which you have to adapt and react quickly. Mainstream arguments I have seen in the above fields are that relaxation is a prerequisite of getting good at these skills: \u0026ldquo;You have to relax or your chords sound horrible!\u0026rdquo;, \u0026ldquo;you have to relax to improve your techniques\u0026rdquo;. Yet most people have to go through a good amount of practice untill they become relaxed and start being good at those skills. Did they not understand how to relax their bodies when they were beginners? Everyone knows how to relax their bodies - just lie on a comfortable massage bed and you will be relax. The hard part is being relax while doing things that we are not good at.\nAnd I would like to argue that relax should come after mastery.\nWhen we first start to learning how to play piano, it feels like our fingers do not belong to us - it is almost an impossible task to control our fingers to work separately and yet cooperatively just to press the right keys without touching the wrong ones at the same time. Is it possibe to be relax at this stage? I am afraid not. It takes huge effort to tame your body to perform tasks that you are unfamiliar at. Being stiff is a sign of using unnecessary energy, which is totally normal when you don\u0026rsquo;t know the right muscles to use or unable to avoid using unnecessary muscles.\nBeing \u0026ldquo;relax\u0026rdquo; is the result of using \u0026ldquo;just right\u0026rdquo; amount of energy - using only the muscles that are needed at the moment. And this is impossible until you acquired the skills and can effortlessly control your body to perform the task - which means mastery. Here mastery doesn\u0026rsquo;t mean being a legendary pianist or a world champ in LOL or jiujitsu, it means you have mastered all the building blocks of your craft and you are ready for the journey of exploring the advanced usages of them, just like a baby finally learnt how to walk steadily - now he knows how to use his feet, so he can freely explore how to jump, how to run\u0026hellip;this is an important milestone of learning.\nThat said, one should notice that it is impossible to be relax before mastery - if you are a beginner in piano can you are completely relax, you are not trying to tame your fingers! You are not trying to make them to do the correct movement! You will inevitably be stiff if you try to do so. And in jiujitsu trying to be relax and look like a seasoned black belt toying people as a white belt will be total bullshit, reality will hit you in your face. You have to try hard to understand every basic technique and know their limits, figure out when does strength work well and when does it not - You have to go through the stiff stage.\nRelaxation should be a sign of mastery, and yet people mistook it as the cause of mastery.\nYour brain is a muscle It is a well-known1 result that human brains are like muscles, they can be trained to become stronger, and they become weaker if lack training. And most great problem solvers tell people that anyone can get better in problem solving by practicing. So it is natural to ask, does relaxation do the same for problem solving? Is the mind of a mature problem solver more relax when solving problems, comparing to that of a naive one? Could relaxation of mind be a sign of mastery of problem solving skills?\nThere are too many times that I think \u0026ldquo;too hard\u0026rdquo; on a problem: I manipulated the mental pictures so hard that I felt my brain was \u0026ldquo;locked\u0026rdquo;.\nAnalogous to muscles, should our mind be relax when we are using the right \u0026ldquo;brain muscles\u0026rdquo; when solving problems? And what are those brain msucles? How could we deliberately practice so that we acquire the skills of using the right muscles faster?\nI would be really interested if others share their experience, and do they feel the same way on how their mind works when solving problems.\nI don\u0026rsquo;t have references to the research papers that discuss these results, but https://www2.cmich.edu/ess/oss/Documents/Prepare%20for%20Success%20d4.pdf could lead one to them.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://katsuragicsl.github.io/blogs/thoughts/relaxation-is-the-result-of-mastery-with-thoughts-about-problem-solving/","summary":"Relaxation as a result of mastery, instead of a prerequisites In many sports/ crafts that I have experienced, relaxation is considered by many the prerequisites of mastery:\nIn playing piano, your fingers, wrists, arms and shoulders have to be relax or you will find it extremely hard to press the right keys fluently; In online games that require fast reactions, rookies hands are stiff and they press buttons with unnecessary strength and range of motion, which stops them from pressing right buttons at the right time smoothly; In jiujitsu, being reasonably relax helps you to perform efficient moves, saving your energy and gives you more choices in different situations in which you have to adapt and react quickly.","title":"Relaxation is the result of mastery. With thoughts about problem solving"},{"content":"Counting binary trees I was thinking about of the problem of balancing a binary tree, and my mind stumbled across to the question \u0026ldquo;How many different binary trees with labelled nodes can you make without changing the traversal order?\u0026rdquo;. After figuring out the answer myself I realized that the numbers of such binary trees are just Catalan numebrs (I was not really into combinatorics - now I am).\nFor example, the following has traversal order 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6-\u0026gt;7\ngraph TB; A((4))--\u003eB((2)) A--\u003eC((6)); B--\u003eE((1)) B--\u003eF((3)) C--\u003eH((5)) C--\u003eI((7)) But the following also has the same traversal order:\ngraph TB; A((4))--\u003eB((3)) A--\u003eC((5)) B--\u003eE((1)) B~~~Hidden1:::hidden E~~~Hidden2:::hidden E--\u003eX((2)) C~~~Hidden3:::hidden C--\u003eI((7)) I--\u003eJ((6)) I~~~Hidden4:::hidden classDef hidden display: none; If we want to maintain the given traversal order while creating with different binary trees, we are essentially counting the number of binary trees that can represent the array $1, 2, 3, \\dots, n$.\nTo construct a binary tree from the given array, there are 2 ways to do so:\nPicking roots in subtrees To create a tree with the array, let\u0026rsquo;s start with picking one of the items as root. Let\u0026rsquo;s say we pick 3 here:\nNow every items before 3 should appears in the left subtree due the way of how traversal order works. Similar for the right subtrees. In order to construct the left/ right subtree, we need to pick the root for them:\nContinue in the same manner, we will get the whole binary tree:\nIt is not hard to see the recursion in this process. After we pick a root, we need to pick the root for the subtrees, which are the same problem with smaller number of nodes. The sizes of the subtrees depends on the choice of the root. By running through all choices of root we have:\nLet $f(n)$ be the number of binary trees desired.\nThen $f(n) = \\sum\\limits_{i=0}^{n-1} f(i)f(n-1-i)$\nPicking legs Draw $n$ nodes with their 2 \u0026ldquo;legs\u0026rdquo;. There are totally $2n$ \u0026ldquo;legs\u0026rdquo;. Each node has a properties called \u0026ldquo;has_parent\u0026rdquo; to keep track of the existence of parent for each node. Initally they are all false. We perform the following:\nDefine the following operations of a node: a. Pick a leg: the leg will be occupied and we have to attach a node to this leg. The node being attached cannot be the root and cannot have a parent. Set the \u0026ldquo;has_parent\u0026rdquo; to true for the attached node. Note that the choice of node being attached is not relevant as the nodes are unlabelled. b. Nullify a leg: the leg will be occupied but we don\u0026rsquo;t attach a node to it. Pick a node and mark it as the root. Set the \u0026ldquo;has_parent\u0026rdquo; to true. Pick one leg of it. Pick a node which has at least one leg not occipied and either pick a leg or nullify a leg of it. Do step 3 until we have picked $n-1$ legs in total. By this process we enumerate all possible binary trees, except some duplicates: In step 2 we picked a node as the root and force it to have at least 1 leg picked, however the nodes should indifferent and the root picking process broke this. As there are $n$ way to pick a root, we should divide the number of possible binary trees by $n$ for deduplication.\nTo see the number of binary trees generated by this process, note that there are $2n$ legs to be picked, and we pick $n-1$ of them. Hence there are $\\binom{2n}{n-1}$ of them. Dividing it by $n$ gives us $\\frac{(2n)!}{(n)!(n+1)!}$ which is the closed form of Catalan numbers.\nFinally note that the number of distinct unlabelled binary trees is the same as distinct labelled binary trees with a given traversal order - there is only 1 way to fill in labels into the nodes such that they match the given traversal order.\n","permalink":"https://katsuragicsl.github.io/blogs/mathematics/reinventing-catalan-numbers/","summary":"Counting binary trees I was thinking about of the problem of balancing a binary tree, and my mind stumbled across to the question \u0026ldquo;How many different binary trees with labelled nodes can you make without changing the traversal order?\u0026rdquo;. After figuring out the answer myself I realized that the numbers of such binary trees are just Catalan numebrs (I was not really into combinatorics - now I am).\nFor example, the following has traversal order 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6-\u0026gt;7","title":"Reinventing Catalan numbers"},{"content":"Defining the machine by describing it In Sipser\u0026rsquo;s Introduction to the theory of computation, a alternative way of defining a Turing machine (other than defining the formal 7-tuple, which is a PITA) - by its \u0026ldquo;description\u0026rdquo;. Example (from the proof of $A_{TM}$ is deciable):\nM = “On input \u0026lt;B, w\u0026gt;, where B is a DFA and w is a string: 1. Simulate B on input w. 2. If the simulation ends in an accept state, accept . If it ends in a nonaccepting state, reject .”\nOf cause, we know that the 7-tuple definition is for the sake of formality, if we have to define and manipulate a 7-tuple machine every time we want to do something with Turing machines, that would be insanely tedious. Hence in the book (and in many other occasions?) the Turing machines are defined by its \u0026ldquo;description\u0026rdquo;, including those relatively complicated ones, such as the Turing machine which can output its own description in the proof of recursion theorem.\nThere is seemingly no restriction of how should a description looks like, so I can create a Turing machine by literally any description, right?\nUnicorn algorithm So what is the problem? In fact this approach makes sense in a great extend: not only it reduces the effort of defining a Turing machine, but it also captures the intuition \u0026ldquo;Turing machines are just programs\u0026rdquo;, so defining a Turing machine is essentially defining an algorithm.\nFor \u0026ldquo;most of the cases\u0026rdquo; this is a safe and good way to deal with Turing machines. But let\u0026rsquo;s consider the following description:\nM = “On input w, give a candy to the unicorn who lives in the Hilbert Grand Hotel. If the unicorn accepts your candy, accept. Otherwise reject .”\nThis is a description right? Does that mean I created a Turing machine and I can call it the unicorn algorithm?\nWell, this is an extreme example, but the point is, the description approach of defining Turing machine is too broad, how can we make sure what we described is not \u0026ldquo;impossible\u0026rdquo;? By \u0026ldquo;possible\u0026rdquo; description, I mean a description that can be computed by a Turing machine, instead of things that cannot be done by Turing machine like ffering a candy to the unicorn. Note that there are some problems that looks pretty sane, but they are beyond the Capability of Turing machines, such as the Busy Beaver problem.\nOK, so what we need is to make sure that what the description is describing can actually be done by a Turing machine, right? Let\u0026rsquo;s call such descriptions as \u0026ldquo;Turing description\u0026rdquo;. But how can we tell? Can we prove/ disprove that? It is also natural to ask: \u0026ldquo;how many Turing description are there?\u0026rdquo;, or the a bit more precise and interesting rephrasing: \u0026ldquo;If I pick a description randomly, how possible is it to be Turing description?\u0026rdquo;\nUnfortunately, we can\u0026rsquo;t.\nFirst of all, by \u0026ldquo;prove/ disprove\u0026rdquo;, it means that we have a step-by-step, mechanical way to deduce its trueness - which means there should be a Turing machine taking the statement as input and return 0 or 1. And this Turing machine has to be a decider if we want to tell whether any given description can be implemented by some Turing machine. Let\u0026rsquo;s call this decider be D and we will show its existence.\nLet\u0026rsquo;s restrict the space of possible description without loss of generality: The description of must be well-defined, as in for any given input, it can tell you whether it accepts or not. (Obviously - otherwise it does not even tell me what does it accept. Note that it is different from assuming it is describing a decider - the description just tells you the result, it does not imply that if you throw an input into the corr. Turing machine (if it exists) the machine will halt.). We also assume takes inputs that Turing machines can take (sure, otherwise we know that is not describing a Turing machine straight away).\nNow note that Turing machine input can be encoded as natural numbers:\nLet the Turing machine be associated with a set of symbols $\\Gamma$ and $|\\Gamma| = N$. Assign numbers $0, 1, 2, \\dots, N-1$ to the symbols. Now the input of tape can be viewed as a N-adic number with the first symbol as the least significant figure. For example when $N = 2$, $0101$ is mapped to $1010_{2} = 10$. Note that this is a bijection between all possible input and $\\mathbb{N}$.\nAlso Note that the existence of blank symbol does not affect our argument, we can simply put it in $\\Gamma$ and consider it as a normal symbol.\nHence a description defined above has implicitly defined a function $f:\\mathbb{N} \\to {0, 1}$ as $0, 1$ represents accept and reject.\nNow, we all know that the set of all possible f is uncountable, and that a given Turing machine can only take countably many distinct input, we can conclude that D does not exist, as it cannot even take all the input that it should take, which is the set of all well-defined description, which is f.\nIs it really\u0026hellip;MOST of the cases? The answer of \u0026ldquo;If I pick a description randomly, how possible is it to be Turing description?\u0026rdquo; should be clear now - \u0026ldquo;almost every function from $\\mathbb{N}$ to ${0, 1}$ is not Turing description, since there are uncountably many functions from $\\mathbb{N}$ to ${0, 1}$, but only countably many Turing machines\u0026rdquo;. This statement trigger a person with mathematics background: \u0026ldquo;So\u0026hellip; does that mean the set of Turing descriptions is of measure zero in the set of functions from $\\mathbb{N}$ to ${0, 1}$\u0026rdquo;. But what is the measure of the set of all functions from $\\mathbb{N}$ to ${0, 1}$?\nI didn\u0026rsquo;t find any articles discussing such measures after a few casual Google searches. We can consider the as a subspace of Baire space and take the \u0026ldquo;common prefix metric\u0026rdquo; i.e. given $x={x_1, x_2, \\dots}$ and $y={y_1, y_2, \\dots}$, $d(x, y) = 0$ if $x=y$, otherwise $d(x, y) = 1/k$ where $k$ is the smallest integer s.t. $x_k \\neq y_k$.\nIn this metric space, the set of Turing descriptions is of (Hausdorff) measure zero: Every Turing description can be covered by an arbitrarily small $k$-ball with it as the center.\nThis looks trivial. Now we want to ask, is non-Turing description dense in Baire space?\nOur intuition tells us that it should true. If you pick a $n$ and flip the value of $f(n)$ of a Turing description, this whole function looks \u0026ldquo;unreasonble\u0026rdquo; now and it would be drastically harder to compute. Now let\u0026rsquo;s check if our Baire space model matches this intuition:\nSuppose the set of non-Turing description is not dense. Then there exists a $f$ in Baire space where $f$ is Turing description s.t. there exists an open ball $B_{1/k}(f)$ s.t. no non-Turing description are in this open ball. But now all element in this open ball are Turing description. Note that there are uncountably many elements in this open ball (since the elements inside are sequences of natural numbers that the first $k$ elements are the same as those of $f$. This whole set is bijective to the whole Baire space and hence uncountable), which means there are uncountably many Turing descriptions in the open ball - which is absurd and we have a contradiction. Hence set of non-Turing description is dense.\nSo, now we can say that Turing descriptions are very rare that almost all functions are not Turing description.\nOutro We have shown that defining a Turing machine by writing down its description can be wrong even when we assume the description is \u0026ldquo;well-formed\u0026rdquo;. As almost every description we write is not Turing description and hence constructing complicated description and just presume that there is a Turing machine for it is problematic.\nTuring descriptions is different from compuatble functions (the Turing machine corr. to a computable function is a decider) and Turing recognizable languages (there could be a Turing machine for a corr. description but it does not halt on every input that the description accepts), but computable functions can be injectively mapped into a subset of the set of Turing machines. Hence we can say that almost every function is uncomputable and the set of uncomputable functions is dense.\nStudy the space of computable functions or other computational objects in topological/ measure theoretical setup would be interesting.\n","permalink":"https://katsuragicsl.github.io/blogs/computer-science/from-casual-description-of-turing-machine-to-uncompuatble-functions/","summary":"Defining the machine by describing it In Sipser\u0026rsquo;s Introduction to the theory of computation, a alternative way of defining a Turing machine (other than defining the formal 7-tuple, which is a PITA) - by its \u0026ldquo;description\u0026rdquo;. Example (from the proof of $A_{TM}$ is deciable):\nM = “On input \u0026lt;B, w\u0026gt;, where B is a DFA and w is a string: 1. Simulate B on input w. 2. If the simulation ends in an accept state, accept .","title":"From casual description of Turing Machine to the density of uncomputable functions"},{"content":"My pc is overheated how do i cool it down because it is my life1 Someone said that chatGPT will replace Google. Some kids/ early teenagers do often ask chatGPT for things that could have been found by Googling.\nI really hate the idea of replacing search engines by chatGPT. The problem I have with it is not really about AI, but about how do we interact with it.\nWhen we were kids and learnt how to use search engines, we acquired the skills of capturing important parts of the questions in our minds and turn them into keywords. Bashing questions like \u0026ldquo;my hard disk is full how can I get more space\u0026rdquo; usually get worse results than things like \u0026ldquo;hard disk space full solutions\u0026rdquo; as their counterparts.\nSame thing applies to going to library and look for related books in the old days: you can\u0026rsquo;t expect to see there is a book titled almost the same as your question, you have to look for the suitable subject and go to the corr. book shelves, look for keywords and sometimes even look for keywords that is a superset of the things you want and hopefully get the answer in one of the chapters. I speculate that this process is important for training our abstraction ability.\nBut the chatGPT allows people to input their braindump like casually talking and get the answer.\nOf cause, one can still train abstraction ability by something else, like in the older days when there were no search engines, even no internet. But if you know how to search, in most cases it would be faster and you will get more firm answers. And I hate the (bad type of) laziness shown when some people keep bashing long stupid questions into chatGPT and satisfied by shallow answers.\nWe all do this, but in other situations I recently learnt the concepts of complementary cognitive artifacts and competitive cognitive artifacts from David Krakauer: https://nautil.us/will-ai-harm-us-better-to-ask-how-well-reckon-with-our-hybrid-nature-236098/ . You can think of them as a fancier way to say things that help you but make you dumb and those don\u0026rsquo;t. Competitiv cognitive artifacts aren\u0026rsquo;t always bad. Calculators are competitiv cognitive artifacts with respect to the ability of doing arithmetics manually. But do I care being bad at it? No. Is it important in general? Meh, most huamn beings don\u0026rsquo;t need to be good at arithmetics (as long as not bad enough to think 1+1=3 and grab 3 items in a buy-one-get-one-free sale and argue with the cashier). But the fluency of turning a question into something that can be googled reflects a basic level of abstraction as a thinking/ problem solving skill.\nWell, the plot twist is, chatGPT fans can argue: \u0026ldquo;You can throw a question or even an article and ask chatGPT to extract the keywords for you!\u0026rdquo;. But I don\u0026rsquo;t think human beings can outsource thinking to machines.\nFirst, for aesthetic reason, the effort of understanding the world and the insights and wisdom gain by ourselves are what makes our lives worth as human beings. Just getting the answer means nothing.\nMoreover, if the service is provided by someone else, namely big techs at this moment, it is possible that it is not a \u0026ldquo;pure\u0026rdquo; LLM, it can be poisoned by artificial (as in artificial intelligence, lol) regulations. lcamtuf talked about this. Imagine a world in where people all believes the standards and decisions from a inhuman intelligent system which is actually just humans like in Psycho-Pass.\nFinal rant Maybe I am too unreconstructed for this generation, but I think we are entering the age of impatience and chatGPT is just yet another product which encourages the culture of impatience.\nFrom https://www.rebootonline.com/blog/men-bing-from-mars-women-google-from-venus/. Disclaimer: nothing sexism such as suggesting women are doing worse here. Just posting the reference of that imaginery search string which was a classic years ago.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://katsuragicsl.github.io/blogs/thoughts/why-do-i-hate-chatgpt/","summary":"My pc is overheated how do i cool it down because it is my life1 Someone said that chatGPT will replace Google. Some kids/ early teenagers do often ask chatGPT for things that could have been found by Googling.\nI really hate the idea of replacing search engines by chatGPT. The problem I have with it is not really about AI, but about how do we interact with it.\nWhen we were kids and learnt how to use search engines, we acquired the skills of capturing important parts of the questions in our minds and turn them into keywords.","title":"Why do I hate using chatGPT to replace search engines"},{"content":"Introduction Recently I am trying to reverse engineering a simple Windows desktop game made with Unity. I took a look on some reference but found that the setup can be a bit frustrating. This post is attempting to make the setup clearer and more followable. Reference links are listed below.\nTools Our target is to decompile and debug the Assembly-CSharp.dll inside the folder \u0026lt;game root folder\u0026gt;\\\u0026lt;GANE_NAME\u0026gt;_Data\\Managed\\, which contains custom code the game developer wrote, not the code of Unity or other frameworks. It is written in C#. We need the below tools:\ndnSpy dotPeek (patched) de4dot Some files from official Unity Setup If you got a DEBUG build of the game, you are lucky, you can skip almost all the steps below and just use dnSpy to decompile, debug and modify the code (discussed below). But if you are not insider of the game development team and the team is not stupid enough (or, unfortunately, didn\u0026rsquo;t get enough sleep) to release a debug build to production, you will be dealing with a RELEASE build.\nFortunately, there is a way to tweak the release build to debug build.\nStep 1 Check the version of Unity of the game. Open the file \u0026lt;game root folder\u0026gt;\\\u0026lt;game name\u0026gt;_Data\\globalgamemanagers.assets with notepad, the version of Unity will be shown at the beginning.\nStep 2 Go to https://unity.com/releases/editor/archive and download the correct version of Unity. Install it.\nStep 3 Go to \u0026lt;Unity root\u0026gt;\\Editor\\Data\\PlaybackEngines\\windowsstandalonesupport\\Variations\\win32_development_mono if the game is 32bit, otherwise go to \u0026lt;Unity root\u0026gt;\\Editor\\Data\\PlaybackEngines\\windowsstandalonesupport\\Variations\\win64_development_mono.\nCopy Data\\Managed folder to the corr. folder of the game. Copy WindowsPlayer.exe and UnityPlayer.dll. Rename to \u0026lt;GAME_NAME\u0026gt;.exe. Copy \u0026lt;Unity root\u0026gt;\\Editor\\Data\\MonoBleedingEdge\\bin\\mono-2.0-bdwgc.dl to \u0026lt;GAME_NAME\u0026gt;\\MonoBleedingEdge. Create of edit boot.config and ensure the line player-connection-debug=1 presents. Step 4 Download this de4dot fork and compile it locally by Visual Studio.\nStep 5 Run de4dot.exe -f Assembly-CSharp.dll -o \u0026lt;output dll location\u0026gt; -fpdb. Remove the output pdb file.\nStep 6 Load the output dll into dotPeek.\nRight click on the output dll and select Export to Project Check the box Create *.pdb file Export Step 7 Run the following command: \u0026quot;%UNITY_MONO%\\bin\\mono.exe\u0026quot; \u0026quot;%UNITY_MONO%\\lib\\mono\\4.5\\pdb2mdb.exe\u0026quot; \u0026quot;\u0026lt;target_assembly_dll\u0026gt;\u0026quot; where \u0026quot;%UNITY_MONO% is equal to \u0026lt;Unity root\u0026gt;\\Editor\\Data\\MonoBleedingEdge.\nYou will get a .mdb file. Now you can debug with dnSpy the dll located in the same folder.\nReference Debugging Unity Games Let\u0026rsquo;s Play with Fire Wiki DotPeek PDB generation for assemblies without debug directory ","permalink":"https://katsuragicsl.github.io/blogs/software-hacking/unity-game-reversing-1/","summary":"Introduction Recently I am trying to reverse engineering a simple Windows desktop game made with Unity. I took a look on some reference but found that the setup can be a bit frustrating. This post is attempting to make the setup clearer and more followable. Reference links are listed below.\nTools Our target is to decompile and debug the Assembly-CSharp.dll inside the folder \u0026lt;game root folder\u0026gt;\\\u0026lt;GANE_NAME\u0026gt;_Data\\Managed\\, which contains custom code the game developer wrote, not the code of Unity or other frameworks.","title":"Unity Game Reversing(1): Setup"},{"content":"Introduction LOTS project, founded by mrd0x, is a collection of websites which is likely be trusted but can be used to evade detection when conducting phishing, C\u0026amp;C, exfiltration and downloading tools. In this post I will introduce a way to abusing PayPal and hopefully will be contributing to the LOTS project.\nThis series is (intentively) for my ideas on novel exfiltration/ C\u0026amp;C channels.\nExfiltraftion by Paypal In Paypal, one can dispute an order and upload his/ her evidence. This feature can be used as data exfiltration channel.\nWhile the document states that the dispute only accepts JPG, GIF, PNG and PDF, it is not complicated to pass this requirement by prepending the magic number of GIF to the file being uploaded (tested in API sandbox):\nprintf \u0026quot;\\x47\\x49\\x46\\x38\\x37\\x61\u0026quot; | cat - realfile \u0026gt; fakegif\nSucessfully uploaded on Paypal:\nAdvantages Evading SSL inspection\nOrganization which cares employees’ privacy (getting more these years) exempts some websites from SSL inspection:\nHealthcare Payments etc Example: Policy of Geoscience Australia (under Australian gov) ","permalink":"https://katsuragicsl.github.io/blogs/red-team/lots-project-paypal/","summary":"Introduction LOTS project, founded by mrd0x, is a collection of websites which is likely be trusted but can be used to evade detection when conducting phishing, C\u0026amp;C, exfiltration and downloading tools. In this post I will introduce a way to abusing PayPal and hopefully will be contributing to the LOTS project.\nThis series is (intentively) for my ideas on novel exfiltration/ C\u0026amp;C channels.\nExfiltraftion by Paypal In Paypal, one can dispute an order and upload his/ her evidence.","title":"LOTS Project - Paypal"},{"content":"Tl;dr - unfixed information disclosure in Prisma Cloud defenders This post is about how to abuse a agent of a cloud security solution to get information which you should not know, like what security controls are applied, what assets the victim owns and the owners of the assets.\nIntroduction A few months ago I was examining the Prisma Cloud configuration of my workplace and accidentally discovered an information disclosure issue of Prisma Cloud defender (the agent). This issue has been reported to Palo Alto as security disclosure, however Palo Alto declared that this is an expected behavior.\nWhile Palo Alto seems not considering it as a problem, I think it is at least a trick for post exploitation. Below is some background knowledge.\nPrisma Cloud Prisma Cloud is a cloud security solution developed by Palo Alto, providing features including monitoring processes in standalone hosts/ run as daemon set in a K8S cluster.\nThis is done by deploying an agent (which is called a defender) in the target host.\nTo do so, one needs permissions to Prisma Cloud in order to get an access token. Defender Manager is the most suitable role for an operator whose manager only wants him to help deploying defenders without letting him/ her know other information, for example monitoring rules.\nDigging the hole host Let\u0026rsquo;s get a Defender Manager role and install a host defender on a linux machine, let\u0026rsquo;s say machine A.\nTake a look at the directory /var/lib/twistlock/local_db/local/\u0026lt;version number\u0026gt;/messages/, connect is a big file containing a lot of configs, while some details are stored in other files in the same directory.\nWhy can I view things that has nothing to do with my host? Other assets like container registries /var/lib/twistlock/local_db/local/\u0026lt;version number\u0026gt;/connect\nFirewall rules that belongs to OTHER hosts /var/lib/twistlock/local_db/local/\u0026lt;version number\u0026gt;/hostAppFirewallPolicy\nContent of custom rules (e.g. process/ network monitoring) /var/lib/twistlock/local_db/local/\u0026lt;version number\u0026gt;/updateCustomRule\nAs a Defender Manager, all you are supposed to have is the root access in the host where the defender to be installed on. However, after installing defenders, you will be able to get information much more than just the info of that host. For example, reading custom rules on other hosts, let say, hosts which are more important and you don\u0026rsquo;t want to get caught when you have the chance to access them.\nThose could help you if you are an internal threat of a company which uses Prisma Cloud but don\u0026rsquo;t know this trick :)\n","permalink":"https://katsuragicsl.github.io/blogs/red-team/prisma-cloud-defenders/","summary":"Tl;dr - unfixed information disclosure in Prisma Cloud defenders This post is about how to abuse a agent of a cloud security solution to get information which you should not know, like what security controls are applied, what assets the victim owns and the owners of the assets.\nIntroduction A few months ago I was examining the Prisma Cloud configuration of my workplace and accidentally discovered an information disclosure issue of Prisma Cloud defender (the agent).","title":"Prisma Cloud Defenders"}]